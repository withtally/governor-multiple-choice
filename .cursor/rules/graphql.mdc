---
description: graphql instructions
globs: 
alwaysApply: false
---

## Rules for GraphQL ##

**GraphQL can become overly complex** fast if you're not careful. But with some smart patterns and tooling, you can keep it lean, maintainable, and scalable.

Here‚Äôs how to **keep your GraphQL stack simple and healthy**:

---

## üß† 1. **Start schema-first, but go small**
Don‚Äôt try to model the whole domain up front.

‚úÖ **Best practice**:
```graphql
type Query {
  user(id: ID!): User
}

type User {
  id: ID!
  name: String!
  email: String!
}
```

Avoid nested, recursive, or deeply relational types early. Just expose simple resources.

---

## üß± 2. **Modularize your schema and resolvers**
Use a file structure like:

```
graphql/
‚îú‚îÄ user/
‚îÇ  ‚îú‚îÄ user.schema.ts
‚îÇ  ‚îú‚îÄ user.resolvers.ts
‚îú‚îÄ index.ts (combines all)
```

Use `mergeTypeDefs` and `mergeResolvers` (from `@graphql-tools`) to compose everything cleanly.

---

## üîÑ 3. **Auto-generate types**
Use [`graphql-codegen`](mdc:https:/www.graphql-code-generator.com) to generate types from your schema and ops.

```bash
pnpm add -D @graphql-codegen/cli
npx graphql-codegen init
```

It keeps your resolver and query types **in sync and type-safe** ‚Äî this helps prevent logic bloat and bugs.

---

## üß™ 4. **Stick to Query ‚Üí Service ‚Üí DB**
Don‚Äôt cram DB logic in the resolvers.

‚úÖ Pattern:
```ts
// user.resolvers.ts
Query: {
  user: (_parent, { id }) => userService.getUser(id),
}
```

This separates concerns and keeps resolvers light and testable.

---

## ‚õî 5. **Avoid GraphQL anti-patterns**

| ‚ùå Bad Practice                  | ‚úÖ Better Alternative                        |
|-------------------------------|---------------------------------------------|
| Overusing `any` or complex input logic | Use codegen + Zod/Yup for validation |
| Resolver logic mixed with DB calls     | Use clean service layer                 |
| Giant monolithic schema               | Use modular, domain-based schema files |
| Query doing too much                 | Split queries and use fragments        |

---

## ‚öôÔ∏è 6. **Use a lean server**

Use [`graphql-yoga`](mdc:https:/the-guild.dev/graphql/yoga-server) ‚Äî it‚Äôs clean, TypeScript-native, and easy to configure.

```bash
pnpm add graphql graphql-yoga
```

Quick setup:

```ts
import { createServer } from 'graphql-yoga'
import { schema } from './graphql'

const server = createServer({ schema })
server.start()
```

---

## üß© 7. **If it grows, layer authorization and validation**
Don‚Äôt build ACL and validation into every resolver.

Instead:
- Use middlewares
- Use schema directives (e.g. `@auth`)
- Or wrap Yoga with plugins

---

## üß≠ TL;DR: How to keep GraphQL simple

| ‚úÖ Do this                                  | ‚ùå Avoid this                            |
|--------------------------------------------|------------------------------------------|
| Modular schema & resolvers                 | Giant files and huge root resolvers      |
| Use `graphql-codegen`                      | Manual types everywhere                  |
| Schema ‚Üí Service ‚Üí DB layering             | Inline logic in resolvers                |
| Use Yoga or Envelop plugins                | Overbuilding with Apollo boilerplate     |
| Validate input with Zod/Yup                | Unchecked args that mutate the DB        |

---

Want a working `graphql-yoga` + Drizzle starter with modular schema and codegen setup?
